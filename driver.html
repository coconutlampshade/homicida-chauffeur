<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Homicidal Chauffeur Problem Simulation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: white;
        }
        #grid {
            display: grid;
            grid-template-columns: repeat(50, 20px);
            grid-template-rows: repeat(50, 20px);
            margin: 20px;
            gap: 1px;
            background-color: #ccc;
        }
        .cell {
            width: 20px;
            height: 20px;
            background-color: white;
            border: 1px solid #ddd;
            position: relative;
        }
        .squad-car {
            position: relative;
            width: 20px;
            height: 20px;
            background-color: #ff0000;
        }
        .crook {
            background-color: #0000ff;
        }
        .arrow-straight {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #ff0000;
            z-index: 2;
            clip-path: polygon(0 0, 100% 50%, 0 100%);
        }
        .arrow-right {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #fe9898;
            z-index: 2;
            clip-path: polygon(0 0, 100% 50%, 0 100%);
        }
    </style>
</head>
<body>
    <h1>Homicidal Chauffeur Problem Simulation</h1>
    <div id="grid"></div>
    <div id="moveCounter">Moves: 0</div>

    <script>
        let gameOver = false;
        let arrowsVisible = false;
        const gridSize = 50;
        let squadCar, crook;
        let gameInterval;
        let moveCount = 0;

        function initGrid() {
            const grid = document.getElementById('grid');
            grid.innerHTML = '';
            for (let i = 0; i < gridSize * gridSize; i++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                grid.appendChild(cell);
            }
            squadCar = { x: 0, y: 0 };
            crook = { x: 25, y: 25 };
            updateGrid();
        }

        function updateGrid() {
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                cell.classList.remove('squad-car', 'crook');
                cell.innerHTML = '';
            });
            
            const squadCarIndex = squadCar.y * gridSize + squadCar.x;
            const crookIndex = crook.y * gridSize + crook.x;
            
            // Add squad car
            const squadCarCell = cells[squadCarIndex];
            squadCarCell.classList.add('squad-car');
            
            // Only create arrows if they don't exist
            let straightArrow = document.querySelector('.arrow-straight');
            let rightArrow = document.querySelector('.arrow-right');
            
            if (!straightArrow) {
                straightArrow = document.createElement('div');
                straightArrow.classList.add('arrow-straight');
            }
            if (!rightArrow) {
                rightArrow = document.createElement('div');
                rightArrow.classList.add('arrow-right');
            }
            
            // Update arrow positions based on current direction
            switch(squadCar.direction) {
                case 0: // Right
                    straightArrow.style.left = '25px';
                    straightArrow.style.top = '5px';
                    straightArrow.style.transform = 'rotate(0deg)';
                    rightArrow.style.left = '5px';
                    rightArrow.style.top = '25px';
                    rightArrow.style.transform = 'rotate(90deg)';
                    break;
                case 1: // Down
                    straightArrow.style.left = '5px';
                    straightArrow.style.top = '25px';
                    straightArrow.style.transform = 'rotate(90deg)';
                    rightArrow.style.left = '-15px';
                    rightArrow.style.top = '5px';
                    rightArrow.style.transform = 'rotate(180deg)';
                    break;
                case 2: // Left
                    straightArrow.style.left = '-15px';
                    straightArrow.style.top = '5px';
                    straightArrow.style.transform = 'rotate(180deg)';
                    rightArrow.style.left = '5px';
                    rightArrow.style.top = '-15px';
                    rightArrow.style.transform = 'rotate(270deg)';
                    break;
                case 3: // Up
                    straightArrow.style.left = '5px';
                    straightArrow.style.top = '-15px';
                    straightArrow.style.transform = 'rotate(270deg)';
                    rightArrow.style.left = '25px';
                    rightArrow.style.top = '5px';
                    rightArrow.style.transform = 'rotate(0deg)';
                    break;
            }
            
            // Move arrows to new squad car cell
            squadCarCell.appendChild(straightArrow);
            squadCarCell.appendChild(rightArrow);
            
            // Add crook
            cells[crookIndex].classList.add('crook');
        }

        // Add event listener for keyboard controls
        document.addEventListener('keydown', handleKeyPress);

        function handleKeyPress(event) {
            // Start game on first key press if not already started
            if (moveCount === 0) {
                startSimulation();
            }

            switch(event.key) {
                case 'ArrowUp':
                    crook.y = (crook.y - 1 + gridSize) % gridSize;
                    break;
                case 'ArrowDown':
                    crook.y = (crook.y + 1) % gridSize;
                    break;
                case 'ArrowLeft':
                    crook.x = (crook.x - 1 + gridSize) % gridSize;
                    break;
                case 'ArrowRight':
                    crook.x = (crook.x + 1) % gridSize;
                    break;
                default:
                    return; // Ignore other keys
            }
            moveCount++;
            updateMoveCounter();
            updateGrid();
            moveSquadCar();
            updateGrid();
            
            if (squadCar.x === crook.x && squadCar.y === crook.y) {
                alert(`Game Over! The squad car caught the crook in ${moveCount} moves!`);
                moveCount = 0;
                startSimulation();
            }
        }

        function startSimulation() {
            if (gameInterval) {
                clearInterval(gameInterval);
            }
            
            squadCar = { x: 0, y: 0, direction: 0 };
            crook = { x: Math.floor(gridSize/2), y: Math.floor(gridSize/2) };
            moveCount = 0;
            updateMoveCounter();
            updateGrid();
        }

        function updateMoveCounter() {
            document.getElementById('moveCounter').textContent = `Moves: ${moveCount}`;
        }

        function moveSquadCar() {
            if (gameOver) return;

            console.log('Moving squad car from:', squadCar.x, squadCar.y, 'direction:', squadCar.direction);

            // Calculate direction to crook
            const dx = crook.x - squadCar.x;
            const dy = crook.y - squadCar.y;

            // Consider all possible moves
            const moves = [
                // Move forward 2
                { dx: 2, dy: 0, dir: 0 },  // Right
                { dx: -2, dy: 0, dir: 2 }, // Left
                { dx: 0, dy: 2, dir: 1 },  // Down
                { dx: 0, dy: -2, dir: 3 }, // Up
                // Move 1, turn, move 1
                { dx: 1, dy: 1, dir: [0, 1] },  // Right then down
                { dx: 1, dy: -1, dir: [0, 3] }, // Right then up
                { dx: -1, dy: 1, dir: [2, 1] }, // Left then down
                { dx: -1, dy: -1, dir: [2, 3] } // Left then up
            ];

            // Calculate best move
            let bestMove = moves[0];
            let shortestDistance = gridSize * 2;

            moves.forEach(move => {
                // Calculate new position after move
                const newX = (squadCar.x + move.dx + gridSize) % gridSize;
                const newY = (squadCar.y + move.dy + gridSize) % gridSize;
                
                // Calculate distance to crook from this position
                const newDx = Math.min(
                    Math.abs(crook.x - newX),
                    Math.abs(crook.x - newX + gridSize),
                    Math.abs(crook.x - newX - gridSize)
                );
                const newDy = Math.min(
                    Math.abs(crook.y - newY),
                    Math.abs(crook.y - newY + gridSize),
                    Math.abs(crook.y - newY - gridSize)
                );
                const distance = Math.sqrt(newDx * newDx + newDy * newDy);

                if (distance < shortestDistance) {
                    shortestDistance = distance;
                    bestMove = move;
                }
            });

            // Execute best move
            if (Array.isArray(bestMove.dir)) {
                // Two-part move
                for (let i = 0; i < 2; i++) {
                    squadCar.direction = bestMove.dir[i];
                    switch(squadCar.direction) {
                        case 0: squadCar.x = (squadCar.x + 1) % gridSize; break;
                        case 1: squadCar.y = (squadCar.y + 1) % gridSize; break;
                        case 2: squadCar.x = (squadCar.x - 1 + gridSize) % gridSize; break;
                        case 3: squadCar.y = (squadCar.y - 1 + gridSize) % gridSize; break;
                    }
                    if (checkCollision()) return;
                    updateGrid();
                }
            } else {
                // Straight move
                squadCar.direction = bestMove.dir;
                for (let i = 0; i < 2; i++) {
                    switch(squadCar.direction) {
                        case 0: squadCar.x = (squadCar.x + 1) % gridSize; break;
                        case 1: squadCar.y = (squadCar.y + 1) % gridSize; break;
                        case 2: squadCar.x = (squadCar.x - 1 + gridSize) % gridSize; break;
                        case 3: squadCar.y = (squadCar.y - 1 + gridSize) % gridSize; break;
                    }
                    if (checkCollision()) return;
                    updateGrid();
                }
            }
        }

        function resetGame() {
            // Reset game state
            gameOver = false;
            moveCount = 0;
            arrowsVisible = false;

            // Reset squad car to starting position
            squadCar.x = 0;
            squadCar.y = 0;
            squadCar.direction = 0;

            // Reset crook to center
            crook.x = Math.floor(gridSize / 2);
            crook.y = Math.floor(gridSize / 2);

            // Update the display
            updateGrid();
        }

        function checkCollision() {
            // Calculate minimum distance considering grid wrapping
            const dx = Math.min(
                Math.abs(crook.x - squadCar.x),
                Math.abs(crook.x - squadCar.x + gridSize),
                Math.abs(crook.x - squadCar.x - gridSize)
            );
            
            const dy = Math.min(
                Math.abs(crook.y - squadCar.y),
                Math.abs(crook.y - squadCar.y + gridSize),
                Math.abs(crook.y - squadCar.y - gridSize)
            );
            
            // Check if in same or adjacent cell
            if (dx <= 1 && dy <= 1) {
                // Update grid one final time to show the catch
                updateGrid();
                
                // Small delay to show final position
                setTimeout(() => {
                    alert('Caught! Click OK to play again.');
                    resetGame();
                }, 100);
                
                return true;
            }
            
            return false;
        }

        window.onload = initGrid;
    </script>
</body>
</html>